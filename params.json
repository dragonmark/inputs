{"name":"Om-inputs","tagline":"A generic Om component to handle inputs","body":"# The goal of this library is to rapidly prototype UI with Om/React\r\n\r\nThe library generates components based on data description.\r\n\r\nThe library uses [Prismatic/Schema](https://github.com/Prismatic/schema) to describe the data.\r\n\r\nUsing Schema allows the :\r\n* Validation of the data ;\r\n* Coercion of String to proper types.\r\n\r\n\r\n## Show me what looks like !\r\n\r\n[See it in action](https://rawgit.com/hiram-madelaine/om-inputs/master/release.html#)\r\n\r\nThe project contains the example that is used in the documentation\r\n\r\nJust clone the repo and run :\r\n\r\n`lein cljsbuild auto`\r\n\r\n`open index.html`\r\n\r\n\r\n## How does it work\r\n\r\n### Anatomy of a component\r\n\r\n\r\nTo build a component we need :\r\n* A name ;\r\n* A description of the fields ;\r\n* A callback function to use the data ;\r\n* Options to customize the component.\r\n\r\n\r\n\r\n#### The component name\r\n\r\nThe name is used :\r\n\r\n* as the React.js display name;\r\n* To differentiate components in the UI.\r\n\r\n\r\n#### Description of the fields\r\n\r\nThe fields of a component are described with Schema :\r\n\r\n##### Supported Schema types\r\n\r\n* s/Str\r\n* s/Int\r\n* s/Inst\r\n* s/enum\r\n* s/Bool\r\n\r\nA value can be nil using s/maybe :\r\n\r\n```\r\n{:person/first-name (s/maybe s/Str)}\r\n\r\n```\r\n\r\n\r\nA key can be optional using s/s/optional-key :\r\n```\r\n {(s/optional-key :person/size) s/Num}\r\n```\r\n\r\n##### Example\r\n\r\n```\r\n(def sch-person {:person/first-name s/Str\r\n                 :person/name s/Str\r\n                 (s/optional-key :person/birthdate) s/Inst\r\n                 (s/optional-key :person/size) s/Int\r\n                 (s/optional-key :person/gender) (s/enum \"M\" \"Ms\")})\r\n```\r\n\r\n#### The calback function\r\n\r\nThe callback function takes the cursor app state, the owner and the entity.\r\n\r\n`(fn [app owner entity])`\r\n\r\n\r\n### Build an Om input component\r\n\r\nTo build an Om input component, just call the function `make-input-comp` with the required parameters :\r\n- A keyword for the component name\r\n- A Prismatic/Schema\r\n- a callback function\r\n\r\nIn this example we build the component :create-person with the Schema seen previously and the callback simply diplay the created map :\r\n\r\n```\r\n(def person-input-view (make-input-comp :create-person sch-person #(js/alert %3)))\r\n```\r\n\r\n\r\n### Translation of the Schema into UI.\r\n\r\n\r\n\r\n#### The form inputs\r\n\r\nEach entry of a schema generate a field in the form.\r\n\r\nHence, the example schema will produce a form with these input fields :\r\n\r\n* A mandatory input of type text for :person/first-name ;\r\n* A mandatory input of type text for :person/name ;\r\n* An optional date input for the :person/birthdate ;\r\n* An optional input that allows only Integer for :person/size ;\r\n* An optional select that that present the choices \"M\" and \"Ms\" ;\r\n* A validation button that trigger the callback.\r\n\r\n#### Fields validation\r\n\r\nThere are two type of validations :\r\n\r\n1.  Schema validation\r\n2.  Verily validation\r\n\r\n##### Schema Validation\r\n\r\nSchema is able to check that a data structure is conform :\r\n\r\nIn case of a map :\r\n\r\n* all required keys are present ;\r\n* All values are of the correct type ;\r\n\r\nThis job is done by Schema/Coercion :\r\nWhen a value is not of the declared type, we have a chance to coerce it in the correct type.\r\n\r\n\r\nThe problem with an HTMl form is that all data are strings.\r\n\r\n* An empty string represents nil\r\n* Other types must be coerced to the correct type : s/Num, s/Int, s/Inst\r\n\r\n\r\n\r\n##### When validations occur ?\r\n\r\n###### Inline validation\r\n\r\nEach field is validated when leaving the input.\r\n\r\nIf the field is required and left empty the field is maked invalid and a tooltip is displayed.\r\n\r\n\r\n\r\n\r\n###### Submission validation\r\n\r\nWhen clicking the action button, the form is validated according to the Schema :\r\n\r\n* A required input must have a non blank value ;\r\n* A coercion appends if needed for type different than s/Str\r\n\r\n\r\n\r\n#### Options\r\n\r\nOptions are a mean to override the default behavior of the library.\r\n\r\nAll options are given in a map.\r\n\r\n\r\n##### Order of fields\r\n\r\nThe schema is a map that can't be ordered so the fields are displayed in a random order.\r\n\r\n\r\nYou can define the total ordering by giving a vector :\r\n\r\n```\r\n(def opts {:order [:person/first-name :person/name :person/gender :person/birthdate :person/size :person/married]})\r\n\r\n```\r\n\r\n\r\n##### Change the rendering (implementation may change)\r\n\r\n\r\nFor example, concerning the enum schema, it is possible to choose between a\r\nselect or a group of radio buttons.\r\n```\r\n(def opts {:person/gender {:type \"radio-group\"}})\r\n\r\n```\r\n\r\n\r\n##### More Complex Validation rules\r\n\r\nIt is possible to add more complex validation rules than the one provided by Schema.\r\n\r\nI chose [Verily](https://github.com/jkk/verily) for the following reasons :\r\n\r\n* the rules can be described as data structure\r\n* the rules are expressed on the whole map not by key.\r\n* It works for Clojure and ClojureScript.\r\n\r\n\r\nMy goal is to be able to plug any other validation framework.\r\n\r\n\r\n######  Add validations rules\r\n\r\n\r\n```\r\n(def opts {:validations [[:min-val 100 :person/size :person-size-min-length]\r\n                         [:email :person/email :bad-email]]})\r\n```\r\n\r\n\r\n\r\n##### Initial value (not implemented yet)\r\n\r\nIt should be possible to have initial values for each field.\r\n\r\n```\r\n(def opts {:init {:person/married true}})\r\n\r\n```\r\n\r\nThe initial data could be retrieved from the cursor app-state.\r\n\r\n\r\n#### i18n\r\n\r\nIt is possible to provide the labels and error messages in multiple languages.\r\nJust put a map in the shared data :\r\n\r\n```\r\n(om/root\r\n app-view\r\n app-state\r\n {:target (. js/document (getElementById \"person\"))\r\n  :shared {:i18n {\"en\" {:language {:action \"Change language\"\r\n                                   :lang {:label \"Language\"\r\n                                          :data {\"en\" \"English\"\r\n                                                 \"fr\" \"French\"}}}\r\n                        :create-person {:action \"Create person\"\r\n                                        :person/name {:label \"Name\"}\r\n                                        :person/birthdate {:label \"Birthday\"}\r\n                                        :person/first-name {:label \"Firstname\"}\r\n                                        :person/size {:label \"Size\"}\r\n                                        :person/gender {:label \"Gender\"\r\n                                                        :data {\"M\" \"Mister\"\r\n                                                               \"Ms\" \"Miss\"}}}}\r\n                  \"fr\" {:language {:action \"Choix de la langue\"\r\n                                   :lang {:label \"Langue\"\r\n                                          :data {\"en\" \"Anglais\"\r\n                                                 \"fr\" \"Français\"}}}\r\n                        :create-person {:action \"Créer personne\"\r\n                                       :person/name {:label \"Nom\"}\r\n                                       :person/first-name {:label \"Prénom\"}\r\n                                       :person/birthdate {:label \"Date de naissance\"}\r\n                                       :person/size {:label \"Taille\"}\r\n                                       :person/gender {:label \"Genre\"\r\n                                                       :data {\"M\" \"Monsieur\"\r\n                                                              \"Ms\" \"Madame\"}}}}}}})\r\n\r\n```\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}